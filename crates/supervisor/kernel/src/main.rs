//! Relis OS - Kernel code.

#![cfg_attr(not(test), no_std)]
#![cfg_attr(test, allow(unused_imports))]
#![cfg_attr(not(test), no_main)]
#![feature(abi_x86_interrupt)]
#![feature(alloc_error_handler)]
#![feature(asm)]
#![feature(assert_matches)]
#![feature(coerce_unsized)]
#![feature(const_fn)]
#![feature(debug_non_exhaustive)]
#![feature(dispatch_from_dyn)]
#![feature(naked_functions)]
#![feature(thread_local)]
#![feature(type_ascription)]
#![feature(unsize)]

use crate::{
    addr::VAddr,
    arch::{
        capability::TopPageTableCap,
        globals::{self, BASE_PAGE_LENGTH},
    },
    capability::{CPoolCap, MapPermissions, Scheduler, TaskBufferPageCap, TaskCap, UntypedCap},
    logging::UnifiedLogger,
    ramdisk::{elf_loader::DefaultElfLoader, ustar::UStarArchive},
    relic_utils::align,
    util::memory_region::MemoryRegion,
};
use elfloader::ElfBinary;
use heapless::Vec;
use relic_abi::bootstrap::BootstrapInfo;
use spin::Mutex;
use std::panic::PanicInfo;

extern crate alloc;
extern crate core as std;

#[macro_use]
extern crate relic_utils;

#[macro_use]
extern crate bitflags;

#[macro_use]
extern crate getset;

#[macro_use]
extern crate log;

#[macro_use]
extern crate lazy_static;

pub mod arch;
pub mod logging;

/// Support for loading of Sigma process.
pub mod ramdisk;

/// Support for addresses.
pub mod addr;

/// Utilities for the kernel.
pub mod util;

/// Support for common capabilities.
pub mod capability;

/// Logic to process syscalls.
pub mod syscall_processor;

// BOOTBOOT is autogenerated. So, we ignore a bunch of warnings.
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
mod bootboot;

/// Logger used by the kernel everywhere. This logger is activated by the architecture
/// level startup once the memory is ready.
pub static KERNEL_LOGGER: UnifiedLogger = UnifiedLogger::new();

/// Entry point for the Operating System. This calls into the bootstrap
/// of architecture.
#[cfg(not(test))]
#[no_mangle]
fn _start() -> ! {
    crate::arch::bootstrap::initialize_bootstrap_core()
}

/// This function is called on panic.
#[cfg_attr(target_os = "none", panic_handler)]
fn _panic_handler(info: &PanicInfo) -> ! {
    error!("Panic: {}", info);
    info!("====== KERNEL_PANIC ======");
    loop {}
}

#[cfg_attr(target_os = "none", alloc_error_handler)]
fn _alloc_error_handler(layout: alloc::alloc::Layout) -> ! {
    panic!("allocation error: {:?}", layout)
}

// Root untyped memory regions
static ROOT_MEM_REGIONS: Mutex<heapless::Vec<UntypedCap, heapless::consts::U32>> =
    Mutex::new(heapless::Vec(heapless::i::Vec::new()));

/// Main Function on bootstrap processor.
/// This function should not return.
pub fn main_bsp(free_regions: Vec<MemoryRegion, heapless::consts::U32>) -> ! {
    info!(target: "main", "Free regions found: {:?}", free_regions);

    let mut bootstrap_info = BootstrapInfo {
        cpool_capability: 0.into(),
        top_level_pml4: 0.into(),
        free_mem_regions: (1.into(), 0.into()),
    };
    let (mut cpool_cap, mut untyped_cap) = {
        let mut root_regions = ROOT_MEM_REGIONS.lock();
        let mut region_iter = free_regions.iter();
        let cpool_target_region = region_iter.next().unwrap();

        let untyped = unsafe {
            UntypedCap::bootstrap(
                cpool_target_region.start_paddr().to_paddr_global(),
                cpool_target_region.length(),
            )
        };
        root_regions.push(untyped.clone()).unwrap();
        let cpool = CPoolCap::retype_from(&mut untyped.write()).unwrap();

        cpool.read().downgrade_at(cpool.clone(), 0).unwrap();
        cpool.read().downgrade_free(untyped.clone()).unwrap();

        let mut untyped_target = untyped;

        for region in region_iter {
            let untyped = unsafe {
                UntypedCap::bootstrap(region.start_paddr().to_paddr_global(), region.length())
            };
            root_regions.push(untyped.clone()).unwrap();
            cpool.read().downgrade_free(untyped.clone()).unwrap();

            if untyped.read().length() > untyped_target.read().length() {
                untyped_target = untyped;
            }
        }

        bootstrap_info.free_mem_regions.1 = (root_regions.len() as u8).into();
        (cpool, untyped_target)
    };

    info!(target: "main", "CPool: {:?}", cpool_cap);
    info!(target: "main", "Untyped: {:?}", untyped_cap);

    let (task_cap, _) = load_sigma(&mut cpool_cap, &mut untyped_cap, bootstrap_info);
    let scheduler = Scheduler::new();
    scheduler.add_task_with_priority(task_cap);
    scheduler.run_forever()
}

fn load_sigma(
    cpool_cap: &mut CPoolCap,
    untyped_cap: &mut UntypedCap,
    mut bootstrap_info: BootstrapInfo,
) -> (TaskCap, TopPageTableCap) {
    let ramdisk: UStarArchive;
    let binary = {
        unsafe {
            let initrd_ptr =
                (bootboot::bootboot.initrd_ptr + globals::MEM_MAP_OFFSET_LOCATION) as *const u8;
            ramdisk = UStarArchive::new(initrd_ptr, bootboot::bootboot.initrd_size as usize);
            info!(target: "load_sigma", "Initrd image is {}", ramdisk);

            let file_name = "./userspace/relic-sigma";
            let file = ramdisk.lookup(file_name).expect("Sigma file not found");
            let binary = ElfBinary::new("relic-sigma", file).expect("Cannot read the binary");
            binary
        }
    };
    let mut loader =
        DefaultElfLoader::new(VAddr::new(0), cpool_cap, &mut bootstrap_info, untyped_cap);
    binary.load(&mut loader).expect("Binary loading failed");
    let loc: u64 = loader.exe_section_location().into();
    info!(target: "load_sigma", 
            "Sigma project loaded. Use comand `add-symbol-file ../../x86_64-relic-user/debug/relic-sigma  0x{:x}`", 
            loc);

    info!(target: "load_sigma", "Loading kernel stack");
    let user_stack_start: u64 = 0x6FFF_000_0000;
    let num_pages = 10usize;
    for page_index in 0..num_pages {
        loader.map_empty_page(
            VAddr::new(user_stack_start + (BASE_PAGE_LENGTH * page_index) as u64),
            MapPermissions::READ | MapPermissions::WRITE,
        )
    }
    let user_stack_end: VAddr = align::align_down(
        user_stack_start + num_pages as u64 * BASE_PAGE_LENGTH as u64 - 1,
        globals::STACK_ALIGN as u64,
    )
    .into();
    info!(target:"load_sigma", "Stack loaded at {:?}", user_stack_end);

    info!(target: "load_sigma", "Loading TaskBuffers");
    let buffer_start: u64 = 0x6000_000_0000;
    let buffer_cap = TaskBufferPageCap::retype_from(&mut *loader.untyped_mut().write()).unwrap();
    let val = loader.cpool().read().downgrade_free(buffer_cap.clone());
    if let Ok(ind) = val {
        info!(target: "load_sigma", "TaskBufferCap is stored at index {}", ind);
    }
    loader
        .map_cap(
            &buffer_cap,
            buffer_start.into(),
            MapPermissions::READ | MapPermissions::WRITE,
        )
        .unwrap();
    buffer_cap.write().write().self_address = buffer_start;
    // Load bootstrap info into payload
    buffer_cap
        .write()
        .write()
        .write_to_task_buffer(&bootstrap_info)
        .unwrap();

    let task_cap = TaskCap::retype_from(&mut *loader.untyped_mut().write(), 15).unwrap();
    {
        let mut task_cap_write = task_cap.write();
        task_cap_write.set_instruction_pointer(binary.entry_point().into());
        task_cap_write.set_stack_pointer(user_stack_end);
        task_cap_write.set_status(capability::TaskStatus::Inactive);
        task_cap_write.downgrade_cpool((*loader.cpool()).clone());
        task_cap_write.downgrade_top_page_table(loader.pml4().clone());
        task_cap_write.downgrade_buffer(buffer_cap.clone());

        task_cap_write.set_tcb_location(buffer_start.into());
    }

    info!(target: "load_sigma", "Sigma task Cap: {:?}", task_cap);
    (task_cap, loader.unwrap())
}
