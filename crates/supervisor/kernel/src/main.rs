//! Relis OS - Kernel code.

#![no_std]
#![cfg_attr(test, allow(unused_imports))]
#![cfg_attr(not(test), no_main)]
#![feature(abi_x86_interrupt)]
#![feature(alloc_error_handler)]
#![feature(asm)]
#![feature(thread_local)]

use crate::logging::UnifiedLogger;
use std::panic::PanicInfo;

extern crate alloc;
extern crate core as std;
extern crate relic_kernel_core;

#[macro_use]
extern crate log;

#[macro_use]
extern crate lazy_static;

pub mod arch;
pub mod logging;

// BOOTBOOT is autogenerated. So, we ignore a bunch of warnings.
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
mod bootboot;

/// Logger used by the kernel everywhere. This logger is activated by the architecture
/// level startup once the memory is ready.
pub static KERNEL_LOGGER: UnifiedLogger = UnifiedLogger::new();

/// Entry point for the Operating System. This calls into the bootstrap
/// of architecture.
#[no_mangle]
fn _start() -> ! {
    crate::arch::bootstrap::initialize_bootstrap_core()
}

/// This function is called on panic.
#[cfg_attr(target_os = "none", panic_handler)]
fn _panic_handler(info: &PanicInfo) -> ! {
    error!("Panic: {}", info);
    info!("====== KERNEL_PANIC ======");
    loop {}
}

#[cfg_attr(target_os = "none", alloc_error_handler)]
fn _alloc_error_handler(layout: alloc::alloc::Layout) -> ! {
    panic!("allocation error: {:?}", layout)
}

/// Main Function on bootstrap processor.
/// This function should not return.
pub fn main_bsp() -> ! {
    loop {}
}
